Sure, here's an example implementation of a custom tree iterator that uses a std::stack and supports both incrementing and decrementing:

```c++
#include <iostream>
#include <stack>
#include <stdexcept>

template <typename T>
class TreeIterator {
private:
    std::stack<T*> stack;
public:
    TreeIterator(T* root) {
        while (root) {
            stack.push(root);
            root = root->left;
        }
    }

    bool operator==(const TreeIterator<T>& other) const {
        return stack == other.stack;
    }

    bool operator!=(const TreeIterator<T>& other) const {
        return !(*this == other);
    }

    T& operator*() const {
        if (stack.empty()) {
            throw std::runtime_error("Iterator out of range");
        }
        return *stack.top();
    }

    T* operator->() const {
        if (stack.empty()) {
            throw std::runtime_error("Iterator out of range");
        }
        return stack.top();
    }

    TreeIterator<T>& operator++() {
        if (stack.empty()) {
            throw std::runtime_error("Iterator out of range");
        }
        T* top = stack.top();
        stack.pop();
        if (top->right) {
            stack.push(top->right);
            while (stack.top()->left) {
                stack.push(stack.top()->left);
            }
        }
        return *this;
    }

    TreeIterator<T> operator++(int) {
        TreeIterator<T> tmp(*this);
        ++(*this);
        return tmp;
    }

    TreeIterator<T>& operator--() {
        if (stack.empty()) {
            throw std::runtime_error("Iterator out of range");
        }
        T* top = stack.top();
        stack.pop();
        if (top->left) {
            stack.push(top->left);
            while (stack.top()->right) {
                stack.push(stack.top()->right);
            }
        }
        return *this;
    }

    TreeIterator<T> operator--(int) {
        TreeIterator<T> tmp(*this);
        --(*this);
        return tmp;
    }
};
```

Here's how you might use the iterator:

```c++
struct Node {
    int value;
    Node* left;
    Node* right;
};

int main() {
    Node node1{1, nullptr, nullptr};
    Node node2{2, nullptr, nullptr};
    Node node3{3, &node1, &node2};
    Node node4{4, nullptr, nullptr};
    Node node5{5, &node3, &node4};

    TreeIterator<Node> it(&node5);
    while (it != TreeIterator<Node>(nullptr)) {
        std::cout << (*it).value << " ";
        ++it;
    }
    std::cout << std::endl;

    TreeIterator<Node> rit(&node2);
    while (rit != TreeIterator<Node>(nullptr)) {
        std::cout << (*rit).value << " ";
        --rit;
    }
    std::cout << std::endl;
    return 0;
}
```

This code creates a binary tree and uses the iterator to traverse it in a depth-first manner. The output should be:

```
1 3 2 5 4
2 3 5
```








Here's an implementation of a custom tree iterator that is based on `std::stack` and supports incrementing and decrementing:

```
template<typename T>
class TreeIterator {
public:
    using value_type = T;
    using pointer = T*;
    using reference = T&;

    TreeIterator() : stack_{} {}

    TreeIterator(Node<value_type>* root) {
        while (root) {
            stack_.push(root);
            root = root->left;
        }
    }

    reference operator*() const {
        return stack_.top()->value;
    }

    pointer operator->() const {
        return &stack_.top()->value;
    }

    TreeIterator& operator++() {
        if (stack_.empty()) {
            return *this;
        }

        if (stack_.top()->right) {
            Node<value_type>* node = stack_.top()->right;
            while (node) {
                stack_.push(node);
                node = node->left;
            }
        } else {
            Node<value_type>* node = stack_.top();
            stack_.pop();
            while (!stack_.empty() && stack_.top()->right == node) {
                node = stack_.top();
                stack_.pop();
            }
        }

        return *this;
    }

    TreeIterator operator++(int) {
        TreeIterator<value_type> it = *this;
        ++*this;
        return it;
    }

    TreeIterator& operator--() {
        if (stack_.empty()) {
            return *this;
        }

        if (stack_.top()->left) {
            Node<value_type>* node = stack_.top()->left;
            while (node) {
                stack_.push(node);
                node = node->right;
            }
        } else {
            Node<value_type>* node = stack_.top();
            stack_.pop();
            while (!stack_.empty() && stack_.top()->left == node) {
                node = stack_.top();
                stack_.pop();
            }
        }

        return *this;
    }

    TreeIterator operator--(int) {
        TreeIterator<value_type> it = *this;
        --*this;
        return it;
    }

    bool operator==(const TreeIterator& other) const {
        return stack_ == other.stack_;
    }

    bool operator!=(const TreeIterator& other) const {
        return !(*this == other);
    }

private:
    std::stack<Node<value_type>*> stack_;
};
```

To use this iterator, you need to implement a `Node` class that represents the nodes in your tree, and a `Tree` class that contains the root and supports `begin()` and `end()` methods that return the beginning and end iterators.

Here's an example implementation of a `Node` class:

```
template<typename T>
class Node {
public:
    Node(const T& value) : value{value}, left{nullptr}, right{nullptr} {}

    T value;
    Node* left;
    Node* right;
};
```

And here's an example implementation of a `Tree` class that contains the root and supports `begin()` and `end()` methods:

```
template<typename T>
class Tree {
public:
    using iterator = TreeIterator<T>;

    Tree() : root{nullptr} {}

    void insert(const T& value) {
        if (!root) {
            root = new Node<T>{value};
        } else {
            Node<T>* node = root;
            while (true) {
                if (value < node->value) {
                    if (!node->left) {
                        node->left = new Node<T>{value};
                        break;
                    } else {
                        node = node->left;
                    }
                } else {
                    if (!node->right) {
                        node->right = new Node<T>{value};
                        break;
                    } else {
                        node = node->right;
                    }
                }
            }
        }
    }

    iterator begin() {
        return iterator{root};
    }

    iterator end() {
        return iterator{};
    }

private:
    Node<T>* root;
};
```

With these implementations, you can use the iterator like this:

```
Tree<int> tree;
tree.insert(4);
tree.insert(2);
tree.insert(1);
tree.insert(3);
tree.insert(6);
tree.insert(5);
tree.insert(7);

for (auto it = tree.begin(); it != tree.end(); ++it) {
    std::cout << *it << " "; // prints "1 2 3 4 5 6 7 "
}

for (auto it = tree.end(); it != tree.begin(); ) {
    std::cout << *(--it) << " "; // prints "7 6 5 4 3 2 1 "
}
```
